---
title: "PHS Summer Prep"
output:
  learnr::tutorial:
    version: 1.1
    theme: paper
runtime: shiny_prerendered
---
```{r setup, include=FALSE}
library(learnr)
knitr::opts_chunk$set(fig.align = "center",
                      cache = TRUE)
tutorial_options(exercise.timelimit = 60)
options(digits = 5, scipen = 999)

pmf_func <- function(x, fx){
  par(mgp = c(3, 1, 0), mar = c(4, 4, 1, 1))
  plot(x, fx, type = "h", col = "blue", xaxt = "n", main = "pmf", ylab = "", xlab = "")
  abline(h = 0)
  points(x, fx, col = "blue", pch = 19)
  axis(1, xaxp = c(min(x), max(x), length(x) - 1))
  title(ylab="f(x)", line = 2, xlab = "x")
}

cdf_func <- function(x, fx){
  par(mgp = c(3, 1, 0), mar = c(4, 4, 1, 1))
  cdf <- c(0, cumsum(fx))
  plot(stepfun(x, cdf),xlab = "",ylab = "", verticals = FALSE, do.points = TRUE, pch = 16, main = "cdf", col = "red")
  points(x, cdf[-length(cdf)], col = "red")
  title(ylab="F(x)", line = 2, xlab = "x")
}

```
```{r, context="render", echo=FALSE}
textOutput("keep_alive")
```
```{r, context="server"}
output$keep_alive <- renderText({
  req(input$alive_count)
  input$alive_count
})
```

## Why and how

#### Why probability and statistics?

You will learn a wide variety of quantitative methods in PHS 2000 from several different fields, which we hope you will find useful in your research. The common backbone to these is probability and statistics. A strong foundation in these concepts is essential for understanding the motivations and implementation of these methods and for seeing how they relate. 

In this tutorial and throughout the course you'll notice that we attempt to represent as much as possible in mathematical notation. As with any other language, mastering this notation helps you communicate efficiently and precisely. However, there's no unified language -- either in English or notation -- across disciplines, and the differences and inconsistencies can be frustrating. One goal of this tutorial is to introduce you to  notation and to formalize some concepts you may already be familiar with, in order to minimize this frustration. Representing methods in mathematical notation can be helpful in making connections to theory and to implementation in code, and it can also help both you and the PHS 2000 teaching team see what you do and don't understand.

If you have taken several statistics courses before, you may be familiar with most or all of the concepts we go through in this tutorial. We nevertheless recommend that you at least read through it so that you have an understanding of what *we* expect you to be familiar with and to make sure you didn't miss anything in your previous courses. If you're not as comfortable with statistics or R or both, take notes as you go along that you can refer back to later. We hope for all of you that this can be a resource that you return to when you encounter difficulties over the course of the next year.

#### Why R?

There are several great options for statistical software out there, and you may already have mastered one or more of them. In fact, it's beneficial for you and your career to be fluent in as many different languages as possible. We have chosen R to use in this class for several reasons. First of all, it's free. You can install it on any and all of the computers you work on. You don't have to go to the computer lab or use a virtual desktop, and you'll never have to buy or renew a license. Second, it's extendable and flexible. This means other people have already written *packages* which contain sets of *functions* that implement a number of common and less common statistical methods. If there's not a package out there that does exactly what you're looking to do, you can write your own functions to do it. We'll see over the course of this year that the ability to write our own own code to implement the methods we learn, as well as simulations to test those methods, is a huge help in understanding the theory behind them.

R is extremely flexible and has a number of capabilities that go beyond statistics. In particular, [R Markdown](https://rmarkdown.rstudio.com) documents can be used to make your research reproducible as well as prepare a number of different types of reports, presentations, and more. In fact, this entire tutorial was written using the `learnr` package in R Markdown.

#### How to use this tutorial

For this tutorial, you don't need to install anything. All the coding takes place within windows on this website itself. At some point before class starts you'll need to install R and its useful companion RStudio if you haven't already. For help with that you can visit [this other tutorial](https://jjallaire.shinyapps.io/learnr-tutorial-00-setup/).

To use the code windows on this website, simply type in the code you want to evaluate and then click "Run Code". (Instead of clicking the button you can also press `control+enter` on a PC or `command+enter` on a Mac while your cursor is in the box.) Some boxes already have code that you just need to run (or which has already been run for you), others will require you to add to or modify what's there, and some are empty and ready for you to fill. They generally only have as much space as you need for a given problem, but will also scroll so you can fill with as many lines of code as necessary (if your code disappears, make sure you haven't scrolled and hidden it, or try clicking the Start Over button).

It may be helpful to install RStudio now and keep an open R document where you keep track of the code you learn in this tutorial and your own notes. If you want to practice changing the code and running it, it may also be easier to do there than in the code boxes here. Note that the objects you create are not generally available in later code boxes in the tutorial, so if you want more practice you should recreate what you do in a separate R session.

The sections have questions and R exercises designed to check your understanding, either interspersed in the text or in a section at the end labeled *Practice*. Think of these as a way to test your knowledge and decide for yourself whether you're ready to move on. None of the questions are graded (and we can't access your results anyway), you get as many tries as you want, and the solutions (and sometimes hints) are available. (If you only see a hint button, the solution is the last available hint.) You can easily copy and paste the solutions, but we suggest that you type them in yourself instead, as it's better practice.

If you don't feel ready to move on, you may want to check out the extra resources links (most of which are videos and practice at Khan Academy) at the bottom of most sections, or the glossary if you're confused by the terminology. R resources are all lumped together in the final section and we highly recommend checking them out to advance your learning, either during or after you've completed this tutorial.

If you come across any errors or have technical difficulties, please notify Louisa, a former PHS 2000 student and Teaching Fellow, at [louisa_h_smith@g.harvard.edu](mailto:louisa_h_smith@g.harvard.edu).

## Intro to R

The first line in following block of code assigns (`<-`) the value 3 to the object `x`. Think of `x` as storing that value: whenever you print `x` (as the second line does), or use it in a function (as in the third line), it is replaced by the value 3.
```{r intro1, exercise = TRUE}
x <- 3
x
x + x
```

Note that, after you run the code, there are two lines of output below the code window. These correspond to each of the lines of code that printed something (the first line assigned but did not print anything; lines with `<-` will generally not produce output, just store, or "save" it to an object). 

If you want, you can just use R as a calculator. Whenever you create something but don't assign it anywhere (i.e., no `<-`), it will just print out the result. Try multiplying 283 $\times$ 598 in the box below:

```{r multiply, exercise = TRUE, exercise.lines = 1}

```

Did you get 169,234? You can do all the normal stuff you'd expect to do with a calculator. Some examples are below, but feel free to play around. Notice first that there are "comments" on several of the lines of code. Everything that follows a `#` sign is not evaluated by R, so you can use comments to explain what your code does or why you're doing it.

```{r calc, exercise = TRUE}
283 * 598
5 ^ 2 # exponents
log(1) # the default logarithm is the natural log, i.e., ln
exp(0) # e^0
sqrt(25)
(4 + 1) * (8 / 2) ^ 3 # expressions follow normal order of operations
```

The above examples were all printed out directly, but we could also assign them to objects, as well as perform functions with them. Objects have case-sensitive names and have certain restrictions like not starting with a number, but other than that, you can basically name things whatever you want. Try to be reasonable, though -- you want your code to be readable and logical. (For more good R practices, check out this [style guide](http://adv-r.had.co.nz/Style.html). You are by no means required to follow it to the letter, but it is always helpful to see how other people format their code.)

Can you figure out what value the object `grape` holds? Write a 4th line of code to print the object and see if you are right.
```{r assign, exercise = TRUE, exercise.lines = 4}
banana <- 5 ^ 2
apple <- sqrt(banana)
grape <- banana - banana / apple
```

```{r assign-solution}
grape
```

Sometimes you'll accidentally do things that are not allowed in R. In this case, you'll get an error message. Some messages are more helpful than others; if you can't figure out what an error message is trying to tell you, it's often helpful to just copy and paste into Google, because chances are someone has had a similar error. Run these lines of code to see the error messages you get (and start to get used to connecting the unhelpful language with the type of problem that produced such an error).
```{r error1, exercise = TRUE, exercise.lines = 2, error = TRUE}
2 <- x 
# can't assign something to a number
```
```{r error2, exercise = TRUE, exercise.lines = 2, error = TRUE}
4 % 2 
# not a function
```
```{r error3, exercise = TRUE, exercise.lines = 2, error = TRUE}
blah 
# we haven't made an object called blah
```
```{r error4, exercise = TRUE, exercise.lines = 2, error = TRUE}
sqrt("4") 
# putting the 4 in quotes makes it a character string, not a number
```
 
#### Quick math review

We saw above that we can use R to do math ... but you need some mathematical intuition as well! One of the most important mathematical concepts to be familiar with for the purposes of PHS 2000 is how exponents and logarithms relate and the ways in which they can be manipulated.

Most of the time in probability and statistics, we use the natural logarithm $\ln(x)$, which we often write as $\log(x)$, and the natural exponential function $e^x$, which we also write as $\exp(x)$. Recall that these are inverse functions:
$$\exp(x) = y \iff x = \log(y)$$
so if one side of an equation is exponentiated, we can always "get out of it" by applying a logarithm to both sides, and vice versa.

When we have a sum inside an exponent, we can decompose this into the product of two exponents: 
$$\exp(a + b) = \exp(a)\exp(b)$$
Similarly, a product inside a logarithm can be written as a sum of logs: 
$$\log(ab) = \log(a) + \log(b)$$
Of course, the same is true of the inverses of addition and multiplication, subtraction and division:
$$\exp(a - b) = \frac{\exp(a)}{\exp(b)}$$
$$\log\left(\frac{a}{b}\right) = \log(a) - \log(b)$$
If we look at these functions on a graph, we can gain some intuition for a few important values you should know.
```{r expGraph, echo = F}
curve(exp(x), xlim = c(-4, 4), ylab = "exp(x)", xlab = "x", main = "exp(x)")
abline(h = 0, lty = "dashed")
points(0, 1, col = "red")
```

We can see that $\lim_{x\to-\infty} \exp(x) = 0$ and $\lim_{x\to\infty} \exp(x) = \infty$. Somewhere in between, we have that $\exp(0) = 1$. This is useful to know since probabilities can only take on values between 0 and 1, so exponentiating a negative number will give you such a value. It is also important to remember that exponentiating something can *only* give you a positive number (so check your work if that's not what you get!).

```{r logGraph, echo = F}
curve(log(x), xlim = c(0, 4), ylab = "log(x)", xlab = "x", main = "log(x)")
abline(h = 0, lty = "dashed")
points(1, 0, col = "red")
```

Because of the inverse relationship of these functions, you can only "log" a positive number. Something like $\log(-1)$ is undefined. We can see that $\lim_{x \to 0}\log(x) = -\infty$, and $\log(x)$ increases in $x$ much more slowly than $\exp(x)$. Importantly, $\log(1) = 0$, so $\log(x)$ for any $x$ between 0 and 1 will give you a negative number. 

You already confirmed above in R that $\log(1) = 0$ and $\exp(0) = 1$. Let's see what we get when we reach the limits of those functions, or when we try to log something outside of its domain. In R, $\infty$ is represented by `Inf`, and you can actually use it in functions. It will also be what's returned to you as soon as a number is "too big", even if it's not actually infinite. Until you reach that point, very large (and very small) numbers are represented with scientific notation, so $\exp(700) = 1.01 \times 10^{304}$ and $\exp(-700) = 9.86 \times 10^{-305}$, as you can see when you run the code below.

```{r inf, exercise = TRUE, exercise.lines = 4}
exp(-Inf)
exp(700)
exp(710)
exp(-700)
```

If you try to do something that is undefined, like take the log of a negative number, you get `NaN`, which stands for "not a number." Interestingly, according to R, $\frac{0}{0}$ is not a number but $\frac{1}{0}$ is infinite, because R is actually returning limits when it returns `Inf` and `-Inf`, which is why we can also evaluate something like $\exp(\infty)$.
```{r nan, exercise = TRUE, exercise.lines = 4}
log(-1)
0/0
1/0
exp(Inf)
```
 
#### *Practice*

**Rearrange these lines of code so that they all run with no errors and the last line prints the value 10.**

```{r prac1a, exercise = TRUE, error = TRUE}
broccoli <- lettuce * 2 / (tomato ^ 2)
broccoli
carrot
carrot <- broccoli + tomato
tomato <- 2
tomato
lettuce <- 4 ^ tomato
```

```{r prac1a-solution}
tomato <- 2
tomato
lettuce <- 4 ^ tomato
broccoli <- lettuce * 2 / (tomato ^ 2)
broccoli
carrot <- broccoli + tomato
carrot
```


**Translate the following math into code:**
$$\log(43 \times 11 + 3!) - \sqrt{e^{(\pi / 7)}} \times \cos(0)$$
```{r prac1c, exercise = TRUE, exercise.lines = 1}

```

```{r prac1c-hint-1}
factorial(3) # = 3!
```

```{r prac1c-hint-2}
cos(pi) # = -1
```

```{r prac1c-hint-3}
log(43 * 11 + factorial(3)) - sqrt(exp(pi/7)) * cos(0)
```

#### More resources
Start [here](https://www.khanacademy.org/math/pre-algebra/pre-algebra-exponents-radicals/pre-algebra-exponent-properties/v/exponent-properties-involving-products) if you need more practice with exponents; [here](https://www.khanacademy.org/math/algebra2/exponential-and-logarithmic-functions) for more practice with logarithms.